{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-764283cb69cf2542063941ab51fa3046ffd30f45",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/GameMarketplace.sol": "project/contracts/GameMarketplace.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.2.0/",
        "project/:@pythnetwork/pyth-sdk-solidity/=npm/@pythnetwork/pyth-sdk-solidity@4.2.0/"
      ]
    },
    "sources": {
      "npm/@pythnetwork/pyth-sdk-solidity@4.2.0/IPyth.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Returns the required fee to update a TWAP price.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getTwapUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime,` but choose to store price updates if `storeUpdatesIfFresh`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// This method will eventually allow the caller to determine whether parsed price feeds should update\n    /// the stored values as well.\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minAllowedPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxAllowedPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @param storeUpdatesIfFresh flag for the parse function to\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesWithConfig(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minAllowedPublishTime,\n        uint64 maxAllowedPublishTime,\n        bool checkUniqueness,\n        bool checkUpdateDataIsMinimal,\n        bool storeUpdatesIfFresh\n    )\n        external\n        payable\n        returns (\n            PythStructs.PriceFeed[] memory priceFeeds,\n            uint64[] memory slots\n        );\n\n    /// @notice Parse time-weighted average price (TWAP) from two consecutive price updates for the given `priceIds`.\n    ///\n    /// This method calculates TWAP between two data points by processing the difference in cumulative price values\n    /// divided by the time period. It requires exactly two updates that contain valid price information\n    /// for all the requested price IDs.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the updateData array.\n    ///\n    /// @dev Reverts if:\n    /// - The transferred fee is not sufficient\n    /// - The updateData is invalid or malformed\n    /// - The updateData array does not contain exactly 2 updates\n    /// - There is no update for any of the given `priceIds`\n    /// - The time ordering between data points is invalid (start time must be before end time)\n    /// @param updateData Array containing exactly two price updates (start and end points for TWAP calculation)\n    /// @param priceIds Array of price ids to calculate TWAP for\n    /// @return twapPriceFeeds Array of TWAP price feeds corresponding to the given `priceIds` (with the same order)\n    function parseTwapPriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds\n    )\n        external\n        payable\n        returns (PythStructs.TwapPriceFeed[] memory twapPriceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.2.0/IPythEvents.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when the TWAP price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param startTime Start time of the TWAP.\n    /// @param endTime End time of the TWAP.\n    /// @param twapPrice Price of the TWAP.\n    /// @param twapConf Confidence interval of the TWAP.\n    /// @param downSlotsRatio Down slot ratio of the TWAP.\n    event TwapPriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 startTime,\n        uint64 endTime,\n        int64 twapPrice,\n        uint64 twapConf,\n        uint32 downSlotsRatio\n    );\n}\n"
      },
      "npm/@pythnetwork/pyth-sdk-solidity@4.2.0/PythStructs.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n\n    struct TwapPriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Start time of the TWAP\n        uint64 startTime;\n        // End time of the TWAP\n        uint64 endTime;\n        // TWAP price\n        Price twap;\n        // Down slot ratio represents the ratio of price feed updates that were missed or unavailable\n        // during the TWAP period, expressed as a fixed-point number between 0 and 1e6 (100%).\n        // For example:\n        //   - 0 means all price updates were available\n        //   - 500_000 means 50% of updates were missed\n        //   - 1_000_000 means all updates were missed\n        // This can be used to assess the quality/reliability of the TWAP calculation.\n        // Applications should define a maximum acceptable ratio (e.g. 100000 for 10%)\n        // and revert if downSlotsRatio exceeds it.\n        uint32 downSlotsRatio;\n    }\n\n    // Information used to calculate time-weighted average prices (TWAP)\n    struct TwapPriceInfo {\n        // slot 1\n        int128 cumulativePrice;\n        uint128 cumulativeConf;\n        // slot 2\n        uint64 numDownSlots;\n        uint64 publishSlot;\n        uint64 publishTime;\n        uint64 prevPublishTime;\n        // slot 3\n        int32 expo;\n    }\n}\n"
      },
      "project/contracts/GameEconomy.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\r\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\r\n\r\n/**\r\n * @title GameEconomy\r\n * @dev Smart contract for dynamic game pricing using Pyth Network price feeds\r\n * @notice This contract enables real-time price adjustments for games based on market conditions\r\n */\r\ncontract GameEconomy {\r\n    IPyth pyth;\r\n    \r\n    // Events\r\n    event GamePriceUpdated(uint256 indexed gameId, uint256 newPrice, int64 ethPrice);\r\n    event GameRegistered(uint256 indexed gameId, address indexed owner, uint256 basePrice);\r\n    event GamePurchased(uint256 indexed gameId, address indexed buyer, uint256 pricePaid);\r\n    \r\n    // Structs\r\n    struct Game {\r\n        uint256 id;\r\n        address owner;\r\n        string metadataHash; // IPFS hash\r\n        uint256 basePriceUSD; // Price in USD cents (e.g., 500 = $5.00)\r\n        uint256 currentPriceWei; // Current price in Wei\r\n        bool isActive;\r\n        uint256 totalSales;\r\n        uint256 createdAt;\r\n    }\r\n    \r\n    struct PriceConfig {\r\n        bytes32 priceFeedId; // Pyth price feed ID\r\n        uint256 volatilityMultiplier; // Multiplier for price volatility (basis points)\r\n        uint256 lastUpdateTime;\r\n        int64 lastPrice;\r\n    }\r\n    \r\n    // Storage\r\n    mapping(uint256 => Game) public games;\r\n    mapping(address => uint256[]) public ownerGames;\r\n    PriceConfig public priceConfig;\r\n    \r\n    uint256 public gameCounter;\r\n    uint256 public constant PLATFORM_FEE = 250; // 2.5% in basis points\r\n    address public platformWallet;\r\n    \r\n    // Price feed configuration\r\n    bytes32 public constant ETH_USD_PRICE_FEED = 0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace; // ETH/USD price feed ID\r\n    \r\n    modifier onlyGameOwner(uint256 gameId) {\r\n        require(games[gameId].owner == msg.sender, \"Not game owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier gameExists(uint256 gameId) {\r\n        require(games[gameId].id == gameId && games[gameId].isActive, \"Game not found or inactive\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _pythAddress, address _platformWallet) {\r\n        pyth = IPyth(_pythAddress);\r\n        platformWallet = _platformWallet;\r\n        \r\n        // Initialize price configuration\r\n        priceConfig = PriceConfig({\r\n            priceFeedId: ETH_USD_PRICE_FEED,\r\n            volatilityMultiplier: 10000, // 100% (no adjustment initially)\r\n            lastUpdateTime: block.timestamp,\r\n            lastPrice: 0\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @dev Register a new game with base USD pricing\r\n     * @param metadataHash IPFS hash containing game metadata\r\n     * @param basePriceUSD Base price in USD cents (e.g., 500 = $5.00)\r\n     */\r\n    function registerGame(string calldata metadataHash, uint256 basePriceUSD) external returns (uint256) {\r\n        require(basePriceUSD > 0, \"Price must be greater than 0\");\r\n        require(bytes(metadataHash).length > 0, \"Metadata hash required\");\r\n        \r\n        gameCounter++;\r\n        uint256 gameId = gameCounter;\r\n        \r\n        // Calculate initial price in Wei\r\n        uint256 initialPriceWei = _calculateGamePriceInWei(basePriceUSD);\r\n        \r\n        games[gameId] = Game({\r\n            id: gameId,\r\n            owner: msg.sender,\r\n            metadataHash: metadataHash,\r\n            basePriceUSD: basePriceUSD,\r\n            currentPriceWei: initialPriceWei,\r\n            isActive: true,\r\n            totalSales: 0,\r\n            createdAt: block.timestamp\r\n        });\r\n        \r\n        ownerGames[msg.sender].push(gameId);\r\n        \r\n        emit GameRegistered(gameId, msg.sender, initialPriceWei);\r\n        return gameId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Purchase a game with dynamic pricing\r\n     * @param gameId The game to purchase\r\n     * @param priceUpdateData Pyth price update data\r\n     */\r\n    function purchaseGame(uint256 gameId, bytes[] calldata priceUpdateData) external payable gameExists(gameId) {\r\n        // Update price feeds\r\n        uint fee = pyth.getUpdateFee(priceUpdateData);\r\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\r\n        \r\n        // Get current game price\r\n        uint256 currentPrice = getCurrentGamePrice(gameId);\r\n        require(msg.value >= currentPrice + fee, \"Insufficient payment\");\r\n        \r\n        Game storage game = games[gameId];\r\n        \r\n        // Calculate platform fee\r\n        uint256 platformFeeAmount = (currentPrice * PLATFORM_FEE) / 10000;\r\n        uint256 ownerAmount = currentPrice - platformFeeAmount;\r\n        \r\n        // Transfer payments\r\n        payable(game.owner).transfer(ownerAmount);\r\n        payable(platformWallet).transfer(platformFeeAmount);\r\n        \r\n        // Refund excess payment\r\n        uint256 totalCost = currentPrice + fee;\r\n        if (msg.value > totalCost) {\r\n            payable(msg.sender).transfer(msg.value - totalCost);\r\n        }\r\n        \r\n        // Update game stats\r\n        game.totalSales++;\r\n        \r\n        emit GamePurchased(gameId, msg.sender, currentPrice);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get current game price in Wei based on USD price and ETH/USD rate\r\n     * @param gameId The game ID\r\n     * @return Current price in Wei\r\n     */\r\n    function getCurrentGamePrice(uint256 gameId) public view gameExists(gameId) returns (uint256) {\r\n        Game memory game = games[gameId];\r\n        return _calculateGamePriceInWei(game.basePriceUSD);\r\n    }\r\n    \r\n    /**\r\n     * @dev Update game price based on current market conditions\r\n     * @param gameId The game to update\r\n     * @param priceUpdateData Pyth price update data\r\n     */\r\n    function updateGamePrice(uint256 gameId, bytes[] calldata priceUpdateData) external payable gameExists(gameId) {\r\n        // Update price feeds\r\n        uint fee = pyth.getUpdateFee(priceUpdateData);\r\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\r\n        \r\n        // Calculate new price\r\n        uint256 newPrice = getCurrentGamePrice(gameId);\r\n        games[gameId].currentPriceWei = newPrice;\r\n        \r\n        // Get current ETH price for event\r\n        PythStructs.Price memory ethPrice = pyth.getPriceUnsafe(ETH_USD_PRICE_FEED);\r\n        \r\n        emit GamePriceUpdated(gameId, newPrice, ethPrice.price);\r\n        \r\n        // Refund excess payment\r\n        if (msg.value > fee) {\r\n            payable(msg.sender).transfer(msg.value - fee);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate game price in Wei based on USD price\r\n     * @param basePriceUSD Price in USD cents\r\n     * @return Price in Wei\r\n     */\r\n    function _calculateGamePriceInWei(uint256 basePriceUSD) internal view returns (uint256) {\r\n        // Get ETH/USD price from Pyth\r\n        PythStructs.Price memory ethPrice = pyth.getPriceUnsafe(ETH_USD_PRICE_FEED);\r\n        require(ethPrice.price > 0, \"Invalid ETH price\");\r\n        \r\n        // Convert price to proper decimals\r\n        // ETH price is typically with 8 decimals, convert to 18 decimals for Wei calculation\r\n        uint256 ethPriceAdjusted = uint256(uint64(ethPrice.price)) * 10**(18 - uint32(-ethPrice.expo));\r\n        \r\n        // Calculate price in Wei\r\n        // basePriceUSD is in cents, so divide by 100 to get dollars\r\n        // Then multiply by 10^18 and divide by ETH price to get Wei\r\n        uint256 priceInWei = (basePriceUSD * 1e18 * 100) / ethPriceAdjusted;\r\n        \r\n        return priceInWei;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get game details\r\n     * @param gameId The game ID\r\n     * @return Game struct data\r\n     */\r\n    function getGame(uint256 gameId) external view returns (Game memory) {\r\n        return games[gameId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get games owned by an address\r\n     * @param owner The owner address\r\n     * @return Array of game IDs\r\n     */\r\n    function getOwnerGames(address owner) external view returns (uint256[] memory) {\r\n        return ownerGames[owner];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get current ETH price from Pyth\r\n     * @return Current ETH/USD price\r\n     */\r\n    function getCurrentETHPrice() external view returns (PythStructs.Price memory) {\r\n        return pyth.getPriceUnsafe(ETH_USD_PRICE_FEED);\r\n    }\r\n    \r\n    /**\r\n     * @dev Update platform fee (only owner)\r\n     * @param newFee New fee in basis points\r\n     */\r\n    function updatePlatformFee(uint256 newFee) external {\r\n        require(msg.sender == platformWallet, \"Only platform can update fee\");\r\n        require(newFee <= 1000, \"Fee cannot exceed 10%\");\r\n        // Platform fee update logic would go here\r\n    }\r\n    \r\n    /**\r\n     * @dev Deactivate a game (only game owner)\r\n     * @param gameId The game to deactivate\r\n     */\r\n    function deactivateGame(uint256 gameId) external onlyGameOwner(gameId) {\r\n        games[gameId].isActive = false;\r\n    }\r\n    \r\n    /**\r\n     * @dev Reactivate a game (only game owner)\r\n     * @param gameId The game to reactivate\r\n     */\r\n    function reactivateGame(uint256 gameId) external onlyGameOwner(gameId) {\r\n        games[gameId].isActive = true;\r\n    }\r\n}"
      },
      "project/contracts/GameMarketplace.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"./GameEconomy.sol\";\r\n\r\n/**\r\n * @title GameMarketplace\r\n * @dev Advanced marketplace with auctions, bundling, and dynamic pricing strategies\r\n * @notice Extends GameEconomy with sophisticated trading mechanisms\r\n */\r\ncontract GameMarketplace is GameEconomy {\r\n    \r\n    // Additional events\r\n    event AuctionCreated(uint256 indexed gameId, uint256 indexed auctionId, uint256 startingBid, uint256 duration);\r\n    event BidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount);\r\n    event AuctionEnded(uint256 indexed auctionId, address indexed winner, uint256 finalBid);\r\n    event BundleCreated(uint256 indexed bundleId, uint256[] gameIds, uint256 price);\r\n    event BundlePurchased(uint256 indexed bundleId, address indexed buyer);\r\n    \r\n    // Structs\r\n    struct Auction {\r\n        uint256 gameId;\r\n        address seller;\r\n        uint256 startingBid;\r\n        uint256 currentBid;\r\n        address currentBidder;\r\n        uint256 endTime;\r\n        bool isActive;\r\n        bool isEnded;\r\n    }\r\n    \r\n    struct Bundle {\r\n        uint256[] gameIds;\r\n        address creator;\r\n        uint256 totalPrice;\r\n        uint256 discountPercent; // Discount in basis points\r\n        bool isActive;\r\n        uint256 createdAt;\r\n    }\r\n    \r\n    struct PricingStrategy {\r\n        uint256 gameId;\r\n        uint256 demandMultiplier; // Multiplier based on demand (basis points)\r\n        uint256 timeDecayRate; // Price decay rate over time (basis points per day)\r\n        uint256 lastSaleTime;\r\n        uint256 saleCount24h;\r\n        bool isDynamic;\r\n    }\r\n    \r\n    // Storage\r\n    mapping(uint256 => Auction) public auctions;\r\n    mapping(uint256 => Bundle) public bundles;\r\n    mapping(uint256 => PricingStrategy) public pricingStrategies;\r\n    mapping(uint256 => mapping(address => uint256)) public auctionBids; // auctionId => bidder => amount\r\n    \r\n    uint256 public auctionCounter;\r\n    uint256 public bundleCounter;\r\n    \r\n    // Constants\r\n    uint256 public constant MIN_AUCTION_DURATION = 1 hours;\r\n    uint256 public constant MAX_AUCTION_DURATION = 7 days;\r\n    uint256 public constant MIN_BID_INCREMENT = 100; // 1% in basis points\r\n    \r\n    modifier validAuction(uint256 auctionId) {\r\n        require(auctions[auctionId].isActive && !auctions[auctionId].isEnded, \"Invalid auction\");\r\n        require(block.timestamp < auctions[auctionId].endTime, \"Auction ended\");\r\n        _;\r\n    }\r\n    \r\n    modifier auctionEnded(uint256 auctionId) {\r\n        require(block.timestamp >= auctions[auctionId].endTime || auctions[auctionId].isEnded, \"Auction not ended\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _pythAddress, address _platformWallet) \r\n        GameEconomy(_pythAddress, _platformWallet) {}\r\n    \r\n    /**\r\n     * @dev Create an auction for a game\r\n     * @param gameId The game to auction\r\n     * @param startingBid Starting bid in Wei\r\n     * @param duration Auction duration in seconds\r\n     */\r\n    function createAuction(\r\n        uint256 gameId, \r\n        uint256 startingBid, \r\n        uint256 duration\r\n    ) external onlyGameOwner(gameId) returns (uint256) {\r\n        require(duration >= MIN_AUCTION_DURATION && duration <= MAX_AUCTION_DURATION, \"Invalid duration\");\r\n        require(startingBid > 0, \"Starting bid must be positive\");\r\n        \r\n        auctionCounter++;\r\n        uint256 auctionId = auctionCounter;\r\n        \r\n        auctions[auctionId] = Auction({\r\n            gameId: gameId,\r\n            seller: msg.sender,\r\n            startingBid: startingBid,\r\n            currentBid: 0,\r\n            currentBidder: address(0),\r\n            endTime: block.timestamp + duration,\r\n            isActive: true,\r\n            isEnded: false\r\n        });\r\n        \r\n        emit AuctionCreated(gameId, auctionId, startingBid, duration);\r\n        return auctionId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Place a bid on an auction\r\n     * @param auctionId The auction to bid on\r\n     */\r\n    function placeBid(uint256 auctionId) external payable validAuction(auctionId) {\r\n        Auction storage auction = auctions[auctionId];\r\n        \r\n        uint256 minBid = auction.currentBid == 0 ? \r\n            auction.startingBid : \r\n            auction.currentBid + (auction.currentBid * MIN_BID_INCREMENT / 10000);\r\n            \r\n        require(msg.value >= minBid, \"Bid too low\");\r\n        require(msg.sender != auction.seller, \"Cannot bid on own auction\");\r\n        \r\n        // Refund previous bidder\r\n        if (auction.currentBidder != address(0)) {\r\n            payable(auction.currentBidder).transfer(auction.currentBid);\r\n        }\r\n        \r\n        auction.currentBid = msg.value;\r\n        auction.currentBidder = msg.sender;\r\n        auctionBids[auctionId][msg.sender] = msg.value;\r\n        \r\n        emit BidPlaced(auctionId, msg.sender, msg.value);\r\n    }\r\n    \r\n    /**\r\n     * @dev End an auction and transfer ownership\r\n     * @param auctionId The auction to end\r\n     */\r\n    function endAuction(uint256 auctionId) external auctionEnded(auctionId) {\r\n        Auction storage auction = auctions[auctionId];\r\n        require(!auction.isEnded, \"Already ended\");\r\n        \r\n        auction.isEnded = true;\r\n        auction.isActive = false;\r\n        \r\n        if (auction.currentBidder != address(0)) {\r\n            // Calculate fees\r\n            uint256 platformFeeAmount = (auction.currentBid * PLATFORM_FEE) / 10000;\r\n            uint256 sellerAmount = auction.currentBid - platformFeeAmount;\r\n            \r\n            // Transfer payments\r\n            payable(auction.seller).transfer(sellerAmount);\r\n            payable(platformWallet).transfer(platformFeeAmount);\r\n            \r\n            // Transfer game ownership (simplified - in practice would need NFT transfer)\r\n            games[auction.gameId].owner = auction.currentBidder;\r\n            \r\n            emit AuctionEnded(auctionId, auction.currentBidder, auction.currentBid);\r\n        } else {\r\n            emit AuctionEnded(auctionId, address(0), 0);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Create a game bundle with discount\r\n     * @param gameIds Array of game IDs to bundle\r\n     * @param discountPercent Discount percentage in basis points\r\n     */\r\n    function createBundle(\r\n        uint256[] calldata gameIds, \r\n        uint256 discountPercent\r\n    ) external returns (uint256) {\r\n        require(gameIds.length >= 2, \"Bundle needs at least 2 games\");\r\n        require(discountPercent <= 5000, \"Discount cannot exceed 50%\");\r\n        \r\n        // Verify ownership of all games\r\n        uint256 totalBasePrice = 0;\r\n        for (uint256 i = 0; i < gameIds.length; i++) {\r\n            require(games[gameIds[i]].owner == msg.sender, \"Must own all games\");\r\n            totalBasePrice += getCurrentGamePrice(gameIds[i]);\r\n        }\r\n        \r\n        bundleCounter++;\r\n        uint256 bundleId = bundleCounter;\r\n        \r\n        uint256 discountedPrice = totalBasePrice - (totalBasePrice * discountPercent / 10000);\r\n        \r\n        bundles[bundleId] = Bundle({\r\n            gameIds: gameIds,\r\n            creator: msg.sender,\r\n            totalPrice: discountedPrice,\r\n            discountPercent: discountPercent,\r\n            isActive: true,\r\n            createdAt: block.timestamp\r\n        });\r\n        \r\n        emit BundleCreated(bundleId, gameIds, discountedPrice);\r\n        return bundleId;\r\n    }\r\n    \r\n    /**\r\n     * @dev Purchase a bundle\r\n     * @param bundleId The bundle to purchase\r\n     * @param priceUpdateData Pyth price update data\r\n     */\r\n    function purchaseBundle(\r\n        uint256 bundleId, \r\n        bytes[] calldata priceUpdateData\r\n    ) external payable {\r\n        Bundle storage bundle = bundles[bundleId];\r\n        require(bundle.isActive, \"Bundle not active\");\r\n        \r\n        // Update price feeds\r\n        uint fee = pyth.getUpdateFee(priceUpdateData);\r\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\r\n        \r\n        require(msg.value >= bundle.totalPrice + fee, \"Insufficient payment\");\r\n        \r\n        // Calculate and transfer fees\r\n        uint256 platformFeeAmount = (bundle.totalPrice * PLATFORM_FEE) / 10000;\r\n        uint256 creatorAmount = bundle.totalPrice - platformFeeAmount;\r\n        \r\n        payable(bundle.creator).transfer(creatorAmount);\r\n        payable(platformWallet).transfer(platformFeeAmount);\r\n        \r\n        // Refund excess\r\n        uint256 totalCost = bundle.totalPrice + fee;\r\n        if (msg.value > totalCost) {\r\n            payable(msg.sender).transfer(msg.value - totalCost);\r\n        }\r\n        \r\n        // Update sales stats for each game\r\n        for (uint256 i = 0; i < bundle.gameIds.length; i++) {\r\n            games[bundle.gameIds[i]].totalSales++;\r\n        }\r\n        \r\n        bundle.isActive = false;\r\n        emit BundlePurchased(bundleId, msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev Enable dynamic pricing for a game\r\n     * @param gameId The game ID\r\n     * @param demandMultiplier Demand-based price multiplier\r\n     * @param timeDecayRate Time-based price decay rate\r\n     */\r\n    function enableDynamicPricing(\r\n        uint256 gameId,\r\n        uint256 demandMultiplier,\r\n        uint256 timeDecayRate\r\n    ) external onlyGameOwner(gameId) {\r\n        pricingStrategies[gameId] = PricingStrategy({\r\n            gameId: gameId,\r\n            demandMultiplier: demandMultiplier,\r\n            timeDecayRate: timeDecayRate,\r\n            lastSaleTime: block.timestamp,\r\n            saleCount24h: 0,\r\n            isDynamic: true\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @dev Get dynamic price for a game\r\n     * @param gameId The game ID\r\n     * @return Adjusted price in Wei\r\n     */\r\n    function getDynamicPrice(uint256 gameId) external view returns (uint256) {\r\n        if (!pricingStrategies[gameId].isDynamic) {\r\n            return getCurrentGamePrice(gameId);\r\n        }\r\n        \r\n        uint256 basePrice = getCurrentGamePrice(gameId);\r\n        PricingStrategy memory strategy = pricingStrategies[gameId];\r\n        \r\n        // Apply demand multiplier based on recent sales\r\n        uint256 demandAdjustedPrice = basePrice * strategy.demandMultiplier / 10000;\r\n        \r\n        // Apply time decay\r\n        uint256 daysSinceLastSale = (block.timestamp - strategy.lastSaleTime) / 1 days;\r\n        uint256 decayAmount = demandAdjustedPrice * strategy.timeDecayRate * daysSinceLastSale / 10000;\r\n        \r\n        if (decayAmount < demandAdjustedPrice) {\r\n            return demandAdjustedPrice - decayAmount;\r\n        }\r\n        \r\n        return demandAdjustedPrice / 2; // Minimum 50% of original price\r\n    }\r\n    \r\n    /**\r\n     * @dev Get bundle details\r\n     * @param bundleId The bundle ID\r\n     * @return Bundle struct data\r\n     */\r\n    function getBundle(uint256 bundleId) external view returns (Bundle memory) {\r\n        return bundles[bundleId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get auction details\r\n     * @param auctionId The auction ID\r\n     * @return Auction struct data\r\n     */\r\n    function getAuction(uint256 auctionId) external view returns (Auction memory) {\r\n        return auctions[auctionId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get pricing strategy for a game\r\n     * @param gameId The game ID\r\n     * @return PricingStrategy struct data\r\n     */\r\n    function getPricingStrategy(uint256 gameId) external view returns (PricingStrategy memory) {\r\n        return pricingStrategies[gameId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency function to cancel auction (only platform)\r\n     * @param auctionId The auction to cancel\r\n     */\r\n    function emergencyCancelAuction(uint256 auctionId) external {\r\n        require(msg.sender == platformWallet, \"Only platform\");\r\n        \r\n        Auction storage auction = auctions[auctionId];\r\n        auction.isActive = false;\r\n        auction.isEnded = true;\r\n        \r\n        // Refund current bidder if exists\r\n        if (auction.currentBidder != address(0)) {\r\n            payable(auction.currentBidder).transfer(auction.currentBid);\r\n        }\r\n    }\r\n}"
      }
    }
  }
}